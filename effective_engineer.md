# Effective Engineer

These notes were taken from [Effective Engineer](https://www.effectiveengineer.com)
by Edmond Lau.

Effective engineers:

* produce results
* get things done efficiently
* focus on value and impact

An effective engineer is defined by the rate at which they produce value per unit of time worked.
These notes cover strategy and tactics to be more effective.

# Adopt the Right Mindset

## Focus on High-Leverage Activities

Try to increase leverage:

```
Leverage = Impact Produced / Time Invested
```

Use leverage as your metric for improvement and always consider:

1. Can I complete this in a shorter amount of time?
2. Can I increase impact produced?
3. Is there anything else I can do instead with more leverage?

## Optimize for Learning

Learning, for depth and breadth, is a high leverage activity. Engineers should always invest in it.
It should be one of your main driving factors when considering jobs.

Some tips:

* adopt a growth mindset!
* learning compounds -- so invest in the rate of learning
* make learning a daily habit
* study code abstractions
* write more code
* take classes related to software engineering
* master programming languages
* get code reviews
* participate in design discussions
* pick diverse projects, pick projects you'll learn from
* learn from senior engineers

## Prioritize Regularly

Regularly review tasks to determine which can produce the most leverage. Prioritize based on ROI.

* important and urgent = crises
* important and not urgent = planning
* not important and urgent = interruptions
* not important and not urgent = busy work

Some tips:

* always ask "Is this the most important thing I should be working on?"
* focus on what produces value the most
* learn to say "No"
* limit amount of work in progress (context switching hurts)

# Execute, Execute, Execute

## Invest in Iteration Speed

Move fast to learn fast. Invest in tools to increase efficiency. Some examples:

* continuous delivery
* shell scripts
* full automation platforms for testing

Optimize unit test coverage/speed, have fast/incremental compiles, shorten debugging loops.

Master your programming environment: editor, language, shell.

## Measure What You Want To Improve

Use metrics to drive progress. Find metrics for measuring delivered business value. If a task
doesn't move the metric, consider not doing it.

Find metrics to:

* help focus on the right things
* maximize impact
* be actionable - engineers can use it to drive decisions
* be responsive - it should provide iterative feedback
* be robust - isn't so fragile
* is high leverage

## Validate Your Ideas Early and Often

Validation can be used to verify your product delivers high impact value -- before investing time
into it. Consider validating with:

* an MVP
* a prototype
* a video
* a landing page with newsletter sign up

Can you also validate smaller projects within a product before implementation? If you're working
alone, be extra careful to get outside feedback.

## Improve Your Project Estimation Skills

Some tips:

* consider the mythical man month
* estimate to reduce risk early
* do the riskiest task first
* break down tasks into smallest possible unit
* let the engineer doing the work also do the estimate
* be careful of anchoring bias
* use historical data
* buffer for unknowns
* remember additional hours cause burnout

# Build Long-Term Value

## Balance Quality with Pragmatism

We want to keep quality high, but not at the cost of a slow velocity. Code should be:

* easy to learn and read
* easy to use without documentation
* hard to misuse
* satisfy requirements
* easy to extend
* appropriate to the audience
* have automated tests
* have a code review process to catch bugs and share knowledge

Also remember to:

* manage complexity through abstraction
* automate testing
* repay technical debt

## Minimize Operational Burden

Do the simple thing first. Is this design/architecture the simplest approach? Keep the number of
technologies low and embrace operational simplicity.

Fail fast and make it visible -- it helps debugging.

Engineers should automate tasks, the payoff is usually worth the initial investment.

## Invest in Your Team's Growth

Some tips for growing:

* hiring is everyone's responsibility
* staff engineers improve their team, principal engineers improve their company, distinguished
  engineers improve their industry
* your career depends on your team's success
* make an onboarding process
* keep shared ownership of code in mind
* do postmortems
* do automated testing
* do code reviews
* optimize for iteration speed
* consider experimentation time
* foster a culture of learning/improvement
